package corefile

import (
	"errors"
	"fmt"
	"reflect"
	"sort"
	"strings"

	"golang.org/x/debug/arch"
	"golang.org/x/debug/dwarf"
)

// OpenProgramOptions describes options for OpenProgram.
type OpenProgramOptions struct {
	// ExecutablePath is the path to the executable that generated the core
	// file being opened. If this is empty, it is inferred from the core file.
	// If the executable path cannot be inferred from the core file, then
	// OpenProgram fails.
	ExecutablePath string

	// Writable specifies whether the core file is opened in writable mode.
	// If true, then the core file may be updated by calling Value.WriteScalar
	// or by mutating Value.Bytes. The executable file is never updated.
	// Updates to the core file may be buffered until the Program is closed.
	Writable bool

	// LoadDynamicLibraries specifies whether dynamic libraries should be
	// loaded. If false, the Program may have incomplete symbol information
	// and an incomplete representation of the virtual address space.
	// TODO: this is currently not supported
	// TODO: also support loading other memory-mapped files (besides just dynamic libs)?
	LoadDynamicLibraries bool
}

// OpenProgram opens a Program from the core file name by corepath.
// OpenProgram currently supports ELF core dumps generated by Linux.
// More file formats may be added in the future.
//
// XXX use readelf on sample corefile and execfiles to see what they have
func OpenProgram(corepath string, options *OpenProgramOptions) (*Program, error) {
	if options == nil {
		options = &OpenProgramOptions{}
	}
	coref, err := mmapOpen(corepath, options.Writable)
	if err != nil {
		return nil, err
	}
	p, err := openProgramInternal(coref, options)
	if err != nil {
		coref.Close()
		return nil, err
	}
	// Now p takes ownership of coref.
	p.filemaps = append(p.filemaps, coref)
	return p, nil
}

func openProgramInternal(coref *mmapFile, options *OpenProgramOptions) (*Program, error) {
	var p *Program
	var osthreads []*OSThread

	// Load data segments, DWARF, and other metadata from coref and execf.
	// TODO: implement for macho and pe?
	rawReaders := map[string]rawProgramReader{
		"ELF": {readELFCore, readELFExec},
	}
	var openErrs []string
	for kind, reader := range rawReaders {
		logf("OpenProgram: trying to open %s as %s", coref.Name(), kind)
		rp, err := newRawProgram(coref, options, reader)
		if err != nil {
			logf("OpenProgram: failed opening %s as %s: %v", coref.Name(), kind, err)
			openErrs = append(openErrs, fmt.Sprintf("%s: %v", kind, err))
			continue
		}
		logf("OpenProgram: opened %s with GOARCH=%s and GOOS=%s", kind, rp.goarch, rp.goos)
		p = &Program{
			GlobalVars: &VarSet{},
			RuntimeLibrary: &RuntimeLibrary{
				Arch:   goarchToArch(rp.goarch),
				GOARCH: rp.goarch,
				GOOS:   rp.goos,
				Vars:   &VarSet{},
			},
			dwarfs:       rp.dwarfs,
			dataSegments: rp.dataSegments,
			filemaps:     rp.filemaps,
		}
		p.RuntimeLibrary.Program = p
		p.RuntimeLibrary.Finalizers.p = p
		p.RuntimeLibrary.GCRoots.p = p
		p.RuntimeLibrary.HeapObjects.p = p
		osthreads = rp.osthreads
		break
	}
	if p == nil {
		return nil, fmt.Errorf("OpenProgram(%s) failed:\n\t%s", coref.Name(), strings.Join(openErrs, "\n\t"))
	}
	p.typeCache.initialize(p)

	// Load global variables from all packages.
	for fname, dw := range p.dwarfs {
		logf("OpenProgram: loading global variables from %s", fname)
		r := dw.Reader()
		for {
			e, err := r.Next()
			if err != nil {
				return nil, err
			}
			if e == nil {
				break
			}

			switch e.Tag {
			case dwarf.TagCompileUnit:
				verbosef("DWARF offset 0x%x: DW_TAG_CompileUnit with lang=%v", e.Offset, e.Val(dwarf.AttrLanguage))
				// Recurse in Go compilation units.
				const dwLangGo = 22
				if lang := e.Val(dwarf.AttrLanguage); lang != nil && reflect.ValueOf(lang).Int() == dwLangGo {
					continue
				}

			case dwarf.TagArrayType, dwarf.TagBaseType, dwarf.TagPointerType, dwarf.TagStructType,
				dwarf.TagSubroutineType, dwarf.TagTypedef, dwarf.TagUnspecifiedType:
				// Extract this type and make sure it's cached.
				dt, err := dw.Type(e.Offset)
				if err != nil {
					return nil, fmt.Errorf("could not read type at offset 0x%x: %v", e.Offset, err)
				}
				t, err := p.typeCache.addDWARF(dt)
				if err != nil {
					return nil, fmt.Errorf("could not convert type at offset 0x%x: %v", e.Offset, err)
				}
				verbosef("DWARF offset 0x%x: loaded type %s", e.Offset, t)

			case dwarf.TagVariable:
				// Extract this global variable.
				fullname := e.Val(dwarf.AttrName).(string)
				pkgPath, name := splitGlobalVariableName(fullname)

				const dwOpAddr = 3
				loc := e.Val(dwarf.AttrLocation).([]uint8)
				if len(loc) == 0 || loc[0] != dwOpAddr {
					logf("UNEXPECTED: DWARF offset 0x%x: DW_TAG_Variable %s has non-absolute location %#v",
						e.Offset, fullname, loc)
					break
				}
				addr := p.RuntimeLibrary.Arch.Uintptr(loc[1:])

				// Extract this variable's type.
				dt, err := dw.EntryType(e)
				if err != nil {
					logf("WARNING: DWARF offset 0x%x: could not read type for global var %s: %v", e.Offset, fullname, err)
					break
				}
				t := p.typeCache.findDWARF(dt)
				if t == nil {
					logf("WARNING: DWARF offset 0x%x: could not find type for global var %s, DWARF type is %s (%T)", e.Offset, fullname, dt, dt)
					break
				}

				// Create the Var.
				ds, ok := p.dataSegments.slice(addr, t.Size())
				if !ok {
					logf("WARNING: DWARF offset 0x%x: cannot find slice for global var %s at addr 0x%x", e.Offset, fullname, addr)
					break
				}
				verbosef("DWARF offset 0x%x: loaded global var %q (pkg %q, name %s) at addr 0x%x with type %s",
					e.Offset, fullname, pkgPath, name, addr, t)
				v := Var{
					Name:    name,
					PkgPath: pkgPath,
					Value: Value{
						Addr:  ds.addr,
						Type:  t,
						Bytes: ds.data,
					},
				}
				var vs *VarSet
				if pkgPath == "" || pkgPath == "runtime" || strings.HasPrefix(pkgPath, "runtime/") {
					vs = p.RuntimeLibrary.Vars
				} else {
					vs = p.GlobalVars
				}
				if err := vs.insert(v); err != nil {
					logf("DWARF offset 0x%x: %v", e.Offset, err)
				}
			}

			// Only process top-level entries in each compilation unit.
			r.SkipChildren()
		}
	}
	p.typeCache.dwarfDone = true

	// Initialize the runtime library.
	if err := p.RuntimeLibrary.initialize(osthreads); err != nil {
		return nil, err
	}
	return p, nil
}

func goarchToArch(goarch string) arch.Architecture {
	switch goarch {
	case "386":
		return arch.X86
	case "amd64":
		return arch.AMD64
	default:
		// TODO: support ppc64 and s390x
		panic(fmt.Sprintf("GOARCH: %s not supported", goarch))
	}
}

// splitPkgPathName splits fullname into pkgPath + name.
// We find the first "." that occurs after the last "/", then split on that period.
func splitPkgPathName(fullname string) (pkgPath string, name string) {
	k := strings.LastIndex(fullname, "/")
	if k < 0 {
		k = 0
	}
	d := strings.Index(fullname[k:], ".")
	if d < 0 {
		return "", fullname
	}
	return fullname[:d+k], fullname[d+k+1:]
}

// splitGlobalVariableName splits fullname into pkgPath + name.
// Like splitPkgPathName, except that internal internal variable
// names like "go.itab.*" get pkgPath = "".
func splitGlobalVariableName(fullname string) (pkgPath string, name string) {
	// "go.itab.{pkgPath.}name,type"
	if strings.HasPrefix(fullname, "go.itab.") && strings.Contains(fullname, ",") {
		return "", fullname
	}
	// "$f32.hex" and "$f64.hex"
	if strings.HasPrefix(fullname, "$f32.") || strings.HasPrefix(fullname, "$f64.") {
		return "", fullname
	}
	// "runtime/cgo(.rodata)"
	if strings.HasPrefix(fullname, "runtime/cgo(") {
		return "", fullname
	}
	return splitPkgPathName(fullname)
}

// Close closes a Program.
func (p *Program) Close() error {
	var errs []string
	for _, f := range p.filemaps {
		if err := f.Close(); err != nil {
			if f.Name() != "" {
				errs = append(errs, fmt.Sprintf("error closing mmapped file %s: %v", f.Name(), err))
			} else {
				errs = append(errs, fmt.Sprintf("error closing anon mapping: %v", err))
			}
		}
	}
	if len(errs) > 0 {
		return errors.New("error closing Program:\n\t" + strings.Join(errs, "\n\t"))
	}
	return nil
}

// rawProgramReader is the interface to reading core and executable files
// of a specific format.
type rawProgramReader struct {
	readCore func(f *mmapFile, rp *rawProgram, openWritable bool) error
	readExec func(f *mmapFile, rp *rawProgram) error
}

type rawProgram struct {
	goarch       string
	goos         string
	dataSegments dataSegments // sorted
	filemaps     []*mmapFile  // mmaps that represent data segments

	// Only set by readCore.
	execpath  string      // inferred from the core file
	osthreads []*OSThread // all threads; might include threads not managed by go (e.g., cgo threads)

	// Only set by readExec.
	dwarfs map[string]*dwarf.Data
}

func newRawProgram(coref *mmapFile, options *OpenProgramOptions, reader rawProgramReader) (out *rawProgram, finalErr error) {
	rp := &rawProgram{
		dwarfs: make(map[string]*dwarf.Data),
	}
	defer func() {
		if finalErr != nil {
			rp.Close()
		}
	}()

	// Read the core file.
	if err := reader.readCore(coref, rp, options.Writable); err != nil {
		return nil, fmt.Errorf("could not read core file: %v", err)
	}

	// Read the executable file. Prefer the path specified in options, if any.
	execpath := options.ExecutablePath
	if execpath == "" {
		execpath = rp.execpath
	}
	if execpath == "" {
		return nil, errors.New("executable path not specified and could not be inferred from the core file")
	}
	logf("OpenProgram: opening executable %s", execpath)
	execf, err := mmapOpen(execpath, false)
	if err != nil {
		return nil, err
	}
	rp.filemaps = append(rp.filemaps, execf)
	if err := reader.readExec(execf, rp); err != nil {
		return nil, fmt.Errorf("could not read executable file %s: %v", execpath, err)
	}

	// TODO: load dynamic libraries?
	return rp, nil
}

func (rp *rawProgram) Close() {
	for _, f := range rp.filemaps {
		f.Close()
	}
}

func (rp *rawProgram) insertDataSegment(addr, size uint64, makeSegment func(addr, size uint64) (dataSegment, error)) error {
	return rp.dataSegments.insert(addr, size, makeSegment)
}

// dataSegment describes a segment of a Program's virtual memory.
type dataSegment struct {
	addr     uint64
	data     []byte // points to mmap’d files
	writable bool   // true if the underlying files were mapped in writable mode
	readable bool   // true if the memory range was readable by the program (e.g., false for stack guards)
}

func (s dataSegment) String() string {
	mode := ""
	if s.readable {
		mode += "R"
	}
	if s.writable {
		mode += "W"
	}
	return fmt.Sprintf("dataSegment{addr:0x%x, size:0x%x, mode:%v}", s.addr, s.size(), mode)
}

// contains reports whether the segment contains the given address.
func (s dataSegment) contains(addr uint64) bool {
	return s.addr <= addr && addr < s.addr+s.size()
}

// containsRange reports whether the segment contains the range [addr, addr+size).
func (s dataSegment) containsRange(addr, size uint64) bool {
	return s.contains(addr) && (size == 0 || s.contains(addr+size-1))
}

// size reports the size of the segment in bytes.
func (s dataSegment) size() uint64 {
	return uint64(len(s.data))
}

// slice takes a slice of the given segment. addr is an absolute address.
// Returns false if [addr,addr+size) is out-of-bounds of s.
func (s dataSegment) slice(addr, size uint64) (dataSegment, bool) {
	offset := addr - s.addr
	if offset > s.size() || offset+size > s.size() {
		return dataSegment{}, false
	}
	return dataSegment{
		addr:     addr,
		data:     s.data[offset : offset+size : offset+size],
		writable: s.writable,
	}, true
}

// suffix is a shorthand for taking a slice of the given segment from
// addr to the end of the segment.
func (s dataSegment) suffix(addr uint64) (dataSegment, bool) {
	return s.slice(addr, s.size()-(addr-s.addr))
}

// dataSegments is a list of virtual memory segments.
type dataSegments []dataSegment

func (ss dataSegments) Len() int           { return len(ss) }
func (ss dataSegments) Swap(i, k int)      { ss[i], ss[k] = ss[k], ss[i] }
func (ss dataSegments) Less(i, k int) bool { return ss[i].addr < ss[k].addr }

// findSegment finds the segment that contains the given address.
func (ss dataSegments) findSegment(addr uint64) (dataSegment, bool) {
	// Binary search for an upper-bound segment, then check
	// if the previous segment contains addr.
	k := sort.Search(len(ss), func(k int) bool {
		return addr < ss[k].addr
	})
	k--
	if k >= 0 && ss[k].contains(addr) {
		return ss[k], true
	}
	return dataSegment{}, false
}

// slice takes a slice at the given address. Fails if the slice is not
// contained within a single segment.
func (ss dataSegments) slice(addr, size uint64) (dataSegment, bool) {
	s, ok := ss.findSegment(addr)
	if !ok {
		return dataSegment{}, false
	}
	return s.slice(addr, size)
}

// insert inserts a range [addr, addr+size) into ss. We maintain an invariant
// that ss is sorted and contains only non-overlapping segments. If the given
// range overlaps an existing segment, the range is split into a set subranges
// that do not overlap any existing segments. If new dataSegments are needed,
// they are created with makeSegment.
func (ss *dataSegments) insert(addr, size uint64, makeSegment func(addr, size uint64) (dataSegment, error)) error {
	if size == 0 {
		return nil
	}

	if sanityChecks {
		defer func() {
			if !sort.IsSorted(*ss) {
				for k, s := range *ss {
					printf("dataSegments[%v] = %s", k, s)
				}
				panic(fmt.Sprintf("dataSegments are not sorted after insert(0x%x, 0x%x)", addr, size))
			}
		}()
	}

	// Binary search for the first segment where s.addr+s.size > addr.
	k := sort.Search(len(*ss), func(k int) bool {
		s := (*ss)[k]
		return s.addr+s.size() > addr
	})

	// (*ss)[k-1] is fully below [addr, addr+size).
	// Starting from k, walk forward and split the range at all overlapping segments.
	for {
		if k == len(*ss) {
			s, err := makeSegment(addr, size)
			if err != nil {
				return err
			}
			logf("loading %s", s)
			*ss = append(*ss, s)
			return nil
		}
		// If any part of the current range lies to the left of segment k,
		// insert a new segment before k.
		if addr < (*ss)[k].addr {
			slen := (*ss)[k].addr - addr
			if slen > size {
				slen = size
			}
			s, err := makeSegment(addr, slen)
			if err != nil {
				return err
			}
			logf("loading %s", s)
			*ss = append((*ss)[:k], append(dataSegments{s}, (*ss)[k:]...)...)
			k++
		}
		// If any part of the current range lies to the right of the current
		// segment, preserve that part of the range and advance to the next segment.
		segEnd := (*ss)[k].addr + (*ss)[k].size()
		rangeEnd := addr + size
		if segEnd < rangeEnd {
			if addr < segEnd {
				addr = segEnd
				size = rangeEnd - segEnd
			}
			k++
			continue
		}
		// No part of the current range lies to the right of the current
		// segment, so we're done.
		return nil
	}
}
